# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateAssertion {
  _avg: AssertionAvgAggregate
  _count: AssertionCountAggregate
  _max: AssertionMaxAggregate
  _min: AssertionMinAggregate
  _sum: AssertionSumAggregate
}

type AggregateAssertionResult {
  _avg: AssertionResultAvgAggregate
  _count: AssertionResultCountAggregate
  _max: AssertionResultMaxAggregate
  _min: AssertionResultMinAggregate
  _sum: AssertionResultSumAggregate
}

type AggregateCollection {
  _avg: CollectionAvgAggregate
  _count: CollectionCountAggregate
  _max: CollectionMaxAggregate
  _min: CollectionMinAggregate
  _sum: CollectionSumAggregate
}

type AggregateCollectionRun {
  _avg: CollectionRunAvgAggregate
  _count: CollectionRunCountAggregate
  _max: CollectionRunMaxAggregate
  _min: CollectionRunMinAggregate
  _sum: CollectionRunSumAggregate
}

type AggregateMonitor {
  _avg: MonitorAvgAggregate
  _count: MonitorCountAggregate
  _max: MonitorMaxAggregate
  _min: MonitorMinAggregate
  _sum: MonitorSumAggregate
}

type AggregateRequest {
  _avg: RequestAvgAggregate
  _count: RequestCountAggregate
  _max: RequestMaxAggregate
  _min: RequestMinAggregate
  _sum: RequestSumAggregate
}

type AggregateResponse {
  _avg: ResponseAvgAggregate
  _count: ResponseCountAggregate
  _max: ResponseMaxAggregate
  _min: ResponseMinAggregate
  _sum: ResponseSumAggregate
}

type Assertion {
  _count: AssertionCount
  assertionResults(cursor: AssertionResultWhereUniqueInput, distinct: [AssertionResultScalarFieldEnum!], orderBy: [AssertionResultOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionResultWhereInput): [AssertionResult!]!
  comparison: String!
  createdAt: DateTime!
  expected: String!
  id: Int!
  property: String!
  request: Request
  requestId: Int
}

type AssertionAvgAggregate {
  id: Float
  requestId: Float
}

input AssertionAvgOrderByAggregateInput {
  id: SortOrder
  requestId: SortOrder
}

type AssertionCount {
  assertionResults: Int!
}

type AssertionCountAggregate {
  _all: Int!
  comparison: Int!
  createdAt: Int!
  expected: Int!
  id: Int!
  property: Int!
  requestId: Int!
}

input AssertionCountOrderByAggregateInput {
  comparison: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

input AssertionCreateInput {
  assertionResults: AssertionResultCreateNestedManyWithoutAssertionInput
  comparison: String!
  createdAt: DateTime
  expected: String!
  property: String!
  request: RequestCreateNestedOneWithoutAssertionsInput
}

input AssertionCreateManyInput {
  comparison: String!
  createdAt: DateTime
  expected: String!
  id: Int
  property: String!
  requestId: Int
}

input AssertionCreateManyRequestInput {
  comparison: String!
  createdAt: DateTime
  expected: String!
  id: Int
  property: String!
}

input AssertionCreateManyRequestInputEnvelope {
  data: [AssertionCreateManyRequestInput!]!
  skipDuplicates: Boolean
}

input AssertionCreateNestedManyWithoutRequestInput {
  connect: [AssertionWhereUniqueInput!]
  connectOrCreate: [AssertionCreateOrConnectWithoutRequestInput!]
  create: [AssertionCreateWithoutRequestInput!]
  createMany: AssertionCreateManyRequestInputEnvelope
}

input AssertionCreateNestedOneWithoutAssertionResultsInput {
  connect: AssertionWhereUniqueInput
  connectOrCreate: AssertionCreateOrConnectWithoutAssertionResultsInput
  create: AssertionCreateWithoutAssertionResultsInput
}

input AssertionCreateOrConnectWithoutAssertionResultsInput {
  create: AssertionCreateWithoutAssertionResultsInput!
  where: AssertionWhereUniqueInput!
}

input AssertionCreateOrConnectWithoutRequestInput {
  create: AssertionCreateWithoutRequestInput!
  where: AssertionWhereUniqueInput!
}

input AssertionCreateWithoutAssertionResultsInput {
  comparison: String!
  createdAt: DateTime
  expected: String!
  property: String!
  request: RequestCreateNestedOneWithoutAssertionsInput
}

input AssertionCreateWithoutRequestInput {
  assertionResults: AssertionResultCreateNestedManyWithoutAssertionInput
  comparison: String!
  createdAt: DateTime
  expected: String!
  property: String!
}

type AssertionGroupBy {
  _avg: AssertionAvgAggregate
  _count: AssertionCountAggregate
  _max: AssertionMaxAggregate
  _min: AssertionMinAggregate
  _sum: AssertionSumAggregate
  comparison: String!
  createdAt: DateTime!
  expected: String!
  id: Int!
  property: String!
  requestId: Int
}

input AssertionListRelationFilter {
  every: AssertionWhereInput
  none: AssertionWhereInput
  some: AssertionWhereInput
}

type AssertionMaxAggregate {
  comparison: String
  createdAt: DateTime
  expected: String
  id: Int
  property: String
  requestId: Int
}

input AssertionMaxOrderByAggregateInput {
  comparison: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

type AssertionMinAggregate {
  comparison: String
  createdAt: DateTime
  expected: String
  id: Int
  property: String
  requestId: Int
}

input AssertionMinOrderByAggregateInput {
  comparison: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

input AssertionOrderByRelationAggregateInput {
  _count: SortOrder
}

input AssertionOrderByWithAggregationInput {
  _avg: AssertionAvgOrderByAggregateInput
  _count: AssertionCountOrderByAggregateInput
  _max: AssertionMaxOrderByAggregateInput
  _min: AssertionMinOrderByAggregateInput
  _sum: AssertionSumOrderByAggregateInput
  comparison: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  requestId: SortOrder
}

input AssertionOrderByWithRelationInput {
  assertionResults: AssertionResultOrderByRelationAggregateInput
  comparison: SortOrder
  createdAt: SortOrder
  expected: SortOrder
  id: SortOrder
  property: SortOrder
  request: RequestOrderByWithRelationInput
  requestId: SortOrder
}

input AssertionRelationFilter {
  is: AssertionWhereInput
  isNot: AssertionWhereInput
}

type AssertionResult {
  actual: String!
  assertion: Assertion
  assertionId: Int
  createdAt: DateTime!
  id: Int!
  pass: Boolean!
  response: Response
  responseId: Int
}

type AssertionResultAvgAggregate {
  assertionId: Float
  id: Float
  responseId: Float
}

input AssertionResultAvgOrderByAggregateInput {
  assertionId: SortOrder
  id: SortOrder
  responseId: SortOrder
}

type AssertionResultCountAggregate {
  _all: Int!
  actual: Int!
  assertionId: Int!
  createdAt: Int!
  id: Int!
  pass: Int!
  responseId: Int!
}

input AssertionResultCountOrderByAggregateInput {
  actual: SortOrder
  assertionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  pass: SortOrder
  responseId: SortOrder
}

input AssertionResultCreateInput {
  actual: String!
  assertion: AssertionCreateNestedOneWithoutAssertionResultsInput
  createdAt: DateTime
  pass: Boolean!
  response: ResponseCreateNestedOneWithoutAssertionResultsInput
}

input AssertionResultCreateManyAssertionInput {
  actual: String!
  createdAt: DateTime
  id: Int
  pass: Boolean!
  responseId: Int
}

input AssertionResultCreateManyAssertionInputEnvelope {
  data: [AssertionResultCreateManyAssertionInput!]!
  skipDuplicates: Boolean
}

input AssertionResultCreateManyInput {
  actual: String!
  assertionId: Int
  createdAt: DateTime
  id: Int
  pass: Boolean!
  responseId: Int
}

input AssertionResultCreateManyResponseInput {
  actual: String!
  assertionId: Int
  createdAt: DateTime
  id: Int
  pass: Boolean!
}

input AssertionResultCreateManyResponseInputEnvelope {
  data: [AssertionResultCreateManyResponseInput!]!
  skipDuplicates: Boolean
}

input AssertionResultCreateNestedManyWithoutAssertionInput {
  connect: [AssertionResultWhereUniqueInput!]
  connectOrCreate: [AssertionResultCreateOrConnectWithoutAssertionInput!]
  create: [AssertionResultCreateWithoutAssertionInput!]
  createMany: AssertionResultCreateManyAssertionInputEnvelope
}

input AssertionResultCreateNestedManyWithoutResponseInput {
  connect: [AssertionResultWhereUniqueInput!]
  connectOrCreate: [AssertionResultCreateOrConnectWithoutResponseInput!]
  create: [AssertionResultCreateWithoutResponseInput!]
  createMany: AssertionResultCreateManyResponseInputEnvelope
}

input AssertionResultCreateOrConnectWithoutAssertionInput {
  create: AssertionResultCreateWithoutAssertionInput!
  where: AssertionResultWhereUniqueInput!
}

input AssertionResultCreateOrConnectWithoutResponseInput {
  create: AssertionResultCreateWithoutResponseInput!
  where: AssertionResultWhereUniqueInput!
}

input AssertionResultCreateWithoutAssertionInput {
  actual: String!
  createdAt: DateTime
  pass: Boolean!
  response: ResponseCreateNestedOneWithoutAssertionResultsInput
}

input AssertionResultCreateWithoutResponseInput {
  actual: String!
  assertion: AssertionCreateNestedOneWithoutAssertionResultsInput
  createdAt: DateTime
  pass: Boolean!
}

type AssertionResultGroupBy {
  _avg: AssertionResultAvgAggregate
  _count: AssertionResultCountAggregate
  _max: AssertionResultMaxAggregate
  _min: AssertionResultMinAggregate
  _sum: AssertionResultSumAggregate
  actual: String!
  assertionId: Int
  createdAt: DateTime!
  id: Int!
  pass: Boolean!
  responseId: Int
}

input AssertionResultListRelationFilter {
  every: AssertionResultWhereInput
  none: AssertionResultWhereInput
  some: AssertionResultWhereInput
}

type AssertionResultMaxAggregate {
  actual: String
  assertionId: Int
  createdAt: DateTime
  id: Int
  pass: Boolean
  responseId: Int
}

input AssertionResultMaxOrderByAggregateInput {
  actual: SortOrder
  assertionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  pass: SortOrder
  responseId: SortOrder
}

type AssertionResultMinAggregate {
  actual: String
  assertionId: Int
  createdAt: DateTime
  id: Int
  pass: Boolean
  responseId: Int
}

input AssertionResultMinOrderByAggregateInput {
  actual: SortOrder
  assertionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  pass: SortOrder
  responseId: SortOrder
}

input AssertionResultOrderByRelationAggregateInput {
  _count: SortOrder
}

input AssertionResultOrderByWithAggregationInput {
  _avg: AssertionResultAvgOrderByAggregateInput
  _count: AssertionResultCountOrderByAggregateInput
  _max: AssertionResultMaxOrderByAggregateInput
  _min: AssertionResultMinOrderByAggregateInput
  _sum: AssertionResultSumOrderByAggregateInput
  actual: SortOrder
  assertionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  pass: SortOrder
  responseId: SortOrder
}

input AssertionResultOrderByWithRelationInput {
  actual: SortOrder
  assertion: AssertionOrderByWithRelationInput
  assertionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  pass: SortOrder
  response: ResponseOrderByWithRelationInput
  responseId: SortOrder
}

enum AssertionResultScalarFieldEnum {
  actual
  assertionId
  createdAt
  id
  pass
  responseId
}

input AssertionResultScalarWhereInput {
  AND: [AssertionResultScalarWhereInput!]
  NOT: [AssertionResultScalarWhereInput!]
  OR: [AssertionResultScalarWhereInput!]
  actual: StringFilter
  assertionId: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  pass: BoolFilter
  responseId: IntNullableFilter
}

input AssertionResultScalarWhereWithAggregatesInput {
  AND: [AssertionResultScalarWhereWithAggregatesInput!]
  NOT: [AssertionResultScalarWhereWithAggregatesInput!]
  OR: [AssertionResultScalarWhereWithAggregatesInput!]
  actual: StringWithAggregatesFilter
  assertionId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  pass: BoolWithAggregatesFilter
  responseId: IntNullableWithAggregatesFilter
}

type AssertionResultSumAggregate {
  assertionId: Int
  id: Int
  responseId: Int
}

input AssertionResultSumOrderByAggregateInput {
  assertionId: SortOrder
  id: SortOrder
  responseId: SortOrder
}

input AssertionResultUpdateInput {
  actual: StringFieldUpdateOperationsInput
  assertion: AssertionUpdateOneWithoutAssertionResultsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  pass: BoolFieldUpdateOperationsInput
  response: ResponseUpdateOneWithoutAssertionResultsNestedInput
}

input AssertionResultUpdateManyMutationInput {
  actual: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  pass: BoolFieldUpdateOperationsInput
}

input AssertionResultUpdateManyWithWhereWithoutAssertionInput {
  data: AssertionResultUpdateManyMutationInput!
  where: AssertionResultScalarWhereInput!
}

input AssertionResultUpdateManyWithWhereWithoutResponseInput {
  data: AssertionResultUpdateManyMutationInput!
  where: AssertionResultScalarWhereInput!
}

input AssertionResultUpdateManyWithoutAssertionNestedInput {
  connect: [AssertionResultWhereUniqueInput!]
  connectOrCreate: [AssertionResultCreateOrConnectWithoutAssertionInput!]
  create: [AssertionResultCreateWithoutAssertionInput!]
  createMany: AssertionResultCreateManyAssertionInputEnvelope
  delete: [AssertionResultWhereUniqueInput!]
  deleteMany: [AssertionResultScalarWhereInput!]
  disconnect: [AssertionResultWhereUniqueInput!]
  set: [AssertionResultWhereUniqueInput!]
  update: [AssertionResultUpdateWithWhereUniqueWithoutAssertionInput!]
  updateMany: [AssertionResultUpdateManyWithWhereWithoutAssertionInput!]
  upsert: [AssertionResultUpsertWithWhereUniqueWithoutAssertionInput!]
}

input AssertionResultUpdateManyWithoutResponseNestedInput {
  connect: [AssertionResultWhereUniqueInput!]
  connectOrCreate: [AssertionResultCreateOrConnectWithoutResponseInput!]
  create: [AssertionResultCreateWithoutResponseInput!]
  createMany: AssertionResultCreateManyResponseInputEnvelope
  delete: [AssertionResultWhereUniqueInput!]
  deleteMany: [AssertionResultScalarWhereInput!]
  disconnect: [AssertionResultWhereUniqueInput!]
  set: [AssertionResultWhereUniqueInput!]
  update: [AssertionResultUpdateWithWhereUniqueWithoutResponseInput!]
  updateMany: [AssertionResultUpdateManyWithWhereWithoutResponseInput!]
  upsert: [AssertionResultUpsertWithWhereUniqueWithoutResponseInput!]
}

input AssertionResultUpdateWithWhereUniqueWithoutAssertionInput {
  data: AssertionResultUpdateWithoutAssertionInput!
  where: AssertionResultWhereUniqueInput!
}

input AssertionResultUpdateWithWhereUniqueWithoutResponseInput {
  data: AssertionResultUpdateWithoutResponseInput!
  where: AssertionResultWhereUniqueInput!
}

input AssertionResultUpdateWithoutAssertionInput {
  actual: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  pass: BoolFieldUpdateOperationsInput
  response: ResponseUpdateOneWithoutAssertionResultsNestedInput
}

input AssertionResultUpdateWithoutResponseInput {
  actual: StringFieldUpdateOperationsInput
  assertion: AssertionUpdateOneWithoutAssertionResultsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  pass: BoolFieldUpdateOperationsInput
}

input AssertionResultUpsertWithWhereUniqueWithoutAssertionInput {
  create: AssertionResultCreateWithoutAssertionInput!
  update: AssertionResultUpdateWithoutAssertionInput!
  where: AssertionResultWhereUniqueInput!
}

input AssertionResultUpsertWithWhereUniqueWithoutResponseInput {
  create: AssertionResultCreateWithoutResponseInput!
  update: AssertionResultUpdateWithoutResponseInput!
  where: AssertionResultWhereUniqueInput!
}

input AssertionResultWhereInput {
  AND: [AssertionResultWhereInput!]
  NOT: [AssertionResultWhereInput!]
  OR: [AssertionResultWhereInput!]
  actual: StringFilter
  assertion: AssertionRelationFilter
  assertionId: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  pass: BoolFilter
  response: ResponseRelationFilter
  responseId: IntNullableFilter
}

input AssertionResultWhereUniqueInput {
  id: Int
}

enum AssertionScalarFieldEnum {
  comparison
  createdAt
  expected
  id
  property
  requestId
}

input AssertionScalarWhereInput {
  AND: [AssertionScalarWhereInput!]
  NOT: [AssertionScalarWhereInput!]
  OR: [AssertionScalarWhereInput!]
  comparison: StringFilter
  createdAt: DateTimeFilter
  expected: StringFilter
  id: IntFilter
  property: StringFilter
  requestId: IntNullableFilter
}

input AssertionScalarWhereWithAggregatesInput {
  AND: [AssertionScalarWhereWithAggregatesInput!]
  NOT: [AssertionScalarWhereWithAggregatesInput!]
  OR: [AssertionScalarWhereWithAggregatesInput!]
  comparison: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  expected: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  property: StringWithAggregatesFilter
  requestId: IntNullableWithAggregatesFilter
}

type AssertionSumAggregate {
  id: Int
  requestId: Int
}

input AssertionSumOrderByAggregateInput {
  id: SortOrder
  requestId: SortOrder
}

input AssertionUpdateInput {
  assertionResults: AssertionResultUpdateManyWithoutAssertionNestedInput
  comparison: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
  request: RequestUpdateOneWithoutAssertionsNestedInput
}

input AssertionUpdateManyMutationInput {
  comparison: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
}

input AssertionUpdateManyWithWhereWithoutRequestInput {
  data: AssertionUpdateManyMutationInput!
  where: AssertionScalarWhereInput!
}

input AssertionUpdateManyWithoutRequestNestedInput {
  connect: [AssertionWhereUniqueInput!]
  connectOrCreate: [AssertionCreateOrConnectWithoutRequestInput!]
  create: [AssertionCreateWithoutRequestInput!]
  createMany: AssertionCreateManyRequestInputEnvelope
  delete: [AssertionWhereUniqueInput!]
  deleteMany: [AssertionScalarWhereInput!]
  disconnect: [AssertionWhereUniqueInput!]
  set: [AssertionWhereUniqueInput!]
  update: [AssertionUpdateWithWhereUniqueWithoutRequestInput!]
  updateMany: [AssertionUpdateManyWithWhereWithoutRequestInput!]
  upsert: [AssertionUpsertWithWhereUniqueWithoutRequestInput!]
}

input AssertionUpdateOneWithoutAssertionResultsNestedInput {
  connect: AssertionWhereUniqueInput
  connectOrCreate: AssertionCreateOrConnectWithoutAssertionResultsInput
  create: AssertionCreateWithoutAssertionResultsInput
  delete: Boolean
  disconnect: Boolean
  update: AssertionUpdateWithoutAssertionResultsInput
  upsert: AssertionUpsertWithoutAssertionResultsInput
}

input AssertionUpdateWithWhereUniqueWithoutRequestInput {
  data: AssertionUpdateWithoutRequestInput!
  where: AssertionWhereUniqueInput!
}

input AssertionUpdateWithoutAssertionResultsInput {
  comparison: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
  request: RequestUpdateOneWithoutAssertionsNestedInput
}

input AssertionUpdateWithoutRequestInput {
  assertionResults: AssertionResultUpdateManyWithoutAssertionNestedInput
  comparison: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  expected: StringFieldUpdateOperationsInput
  property: StringFieldUpdateOperationsInput
}

input AssertionUpsertWithWhereUniqueWithoutRequestInput {
  create: AssertionCreateWithoutRequestInput!
  update: AssertionUpdateWithoutRequestInput!
  where: AssertionWhereUniqueInput!
}

input AssertionUpsertWithoutAssertionResultsInput {
  create: AssertionCreateWithoutAssertionResultsInput!
  update: AssertionUpdateWithoutAssertionResultsInput!
}

input AssertionWhereInput {
  AND: [AssertionWhereInput!]
  NOT: [AssertionWhereInput!]
  OR: [AssertionWhereInput!]
  assertionResults: AssertionResultListRelationFilter
  comparison: StringFilter
  createdAt: DateTimeFilter
  expected: StringFilter
  id: IntFilter
  property: StringFilter
  request: RequestRelationFilter
  requestId: IntNullableFilter
}

input AssertionWhereUniqueInput {
  id: Int
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

type Collection {
  _count: CollectionCount
  collectionRuns(cursor: CollectionRunWhereUniqueInput, distinct: [CollectionRunScalarFieldEnum!], orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): [CollectionRun!]!
  createdAt: DateTime!
  id: Int!
  monitor: Monitor
  monitorId: Int
  requests(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  title: String!
}

type CollectionAvgAggregate {
  id: Float
  monitorId: Float
}

input CollectionAvgOrderByAggregateInput {
  id: SortOrder
  monitorId: SortOrder
}

type CollectionCount {
  collectionRuns: Int!
  requests: Int!
}

type CollectionCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  monitorId: Int!
  title: Int!
}

input CollectionCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  monitorId: SortOrder
  title: SortOrder
}

input CollectionCreateInput {
  collectionRuns: CollectionRunCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  monitor: MonitorCreateNestedOneWithoutCollectionsInput
  requests: RequestCreateNestedManyWithoutCollectionInput
  title: String!
}

input CollectionCreateManyInput {
  createdAt: DateTime
  id: Int
  monitorId: Int
  title: String!
}

input CollectionCreateManyMonitorInput {
  createdAt: DateTime
  id: Int
  title: String!
}

input CollectionCreateManyMonitorInputEnvelope {
  data: [CollectionCreateManyMonitorInput!]!
  skipDuplicates: Boolean
}

input CollectionCreateNestedManyWithoutMonitorInput {
  connect: [CollectionWhereUniqueInput!]
  connectOrCreate: [CollectionCreateOrConnectWithoutMonitorInput!]
  create: [CollectionCreateWithoutMonitorInput!]
  createMany: CollectionCreateManyMonitorInputEnvelope
}

input CollectionCreateNestedOneWithoutCollectionRunsInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutCollectionRunsInput
  create: CollectionCreateWithoutCollectionRunsInput
}

input CollectionCreateNestedOneWithoutRequestsInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutRequestsInput
  create: CollectionCreateWithoutRequestsInput
}

input CollectionCreateOrConnectWithoutCollectionRunsInput {
  create: CollectionCreateWithoutCollectionRunsInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateOrConnectWithoutMonitorInput {
  create: CollectionCreateWithoutMonitorInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateOrConnectWithoutRequestsInput {
  create: CollectionCreateWithoutRequestsInput!
  where: CollectionWhereUniqueInput!
}

input CollectionCreateWithoutCollectionRunsInput {
  createdAt: DateTime
  monitor: MonitorCreateNestedOneWithoutCollectionsInput
  requests: RequestCreateNestedManyWithoutCollectionInput
  title: String!
}

input CollectionCreateWithoutMonitorInput {
  collectionRuns: CollectionRunCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  requests: RequestCreateNestedManyWithoutCollectionInput
  title: String!
}

input CollectionCreateWithoutRequestsInput {
  collectionRuns: CollectionRunCreateNestedManyWithoutCollectionInput
  createdAt: DateTime
  monitor: MonitorCreateNestedOneWithoutCollectionsInput
  title: String!
}

type CollectionGroupBy {
  _avg: CollectionAvgAggregate
  _count: CollectionCountAggregate
  _max: CollectionMaxAggregate
  _min: CollectionMinAggregate
  _sum: CollectionSumAggregate
  createdAt: DateTime!
  id: Int!
  monitorId: Int
  title: String!
}

input CollectionListRelationFilter {
  every: CollectionWhereInput
  none: CollectionWhereInput
  some: CollectionWhereInput
}

type CollectionMaxAggregate {
  createdAt: DateTime
  id: Int
  monitorId: Int
  title: String
}

input CollectionMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  monitorId: SortOrder
  title: SortOrder
}

type CollectionMinAggregate {
  createdAt: DateTime
  id: Int
  monitorId: Int
  title: String
}

input CollectionMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  monitorId: SortOrder
  title: SortOrder
}

input CollectionOrderByRelationAggregateInput {
  _count: SortOrder
}

input CollectionOrderByWithAggregationInput {
  _avg: CollectionAvgOrderByAggregateInput
  _count: CollectionCountOrderByAggregateInput
  _max: CollectionMaxOrderByAggregateInput
  _min: CollectionMinOrderByAggregateInput
  _sum: CollectionSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  monitorId: SortOrder
  title: SortOrder
}

input CollectionOrderByWithRelationInput {
  collectionRuns: CollectionRunOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  monitor: MonitorOrderByWithRelationInput
  monitorId: SortOrder
  requests: RequestOrderByRelationAggregateInput
  title: SortOrder
}

input CollectionRelationFilter {
  is: CollectionWhereInput
  isNot: CollectionWhereInput
}

type CollectionRun {
  _count: CollectionRunCount
  collection: Collection
  collectionId: Int
  createdAt: DateTime!
  id: Int!
  responses(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): [Response!]!
}

type CollectionRunAvgAggregate {
  collectionId: Float
  id: Float
}

input CollectionRunAvgOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
}

type CollectionRunCount {
  responses: Int!
}

type CollectionRunCountAggregate {
  _all: Int!
  collectionId: Int!
  createdAt: Int!
  id: Int!
}

input CollectionRunCountOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
}

input CollectionRunCreateInput {
  collection: CollectionCreateNestedOneWithoutCollectionRunsInput
  createdAt: DateTime
  responses: ResponseCreateNestedManyWithoutCollectionRunInput
}

input CollectionRunCreateManyCollectionInput {
  createdAt: DateTime
  id: Int
}

input CollectionRunCreateManyCollectionInputEnvelope {
  data: [CollectionRunCreateManyCollectionInput!]!
  skipDuplicates: Boolean
}

input CollectionRunCreateManyInput {
  collectionId: Int
  createdAt: DateTime
  id: Int
}

input CollectionRunCreateNestedManyWithoutCollectionInput {
  connect: [CollectionRunWhereUniqueInput!]
  connectOrCreate: [CollectionRunCreateOrConnectWithoutCollectionInput!]
  create: [CollectionRunCreateWithoutCollectionInput!]
  createMany: CollectionRunCreateManyCollectionInputEnvelope
}

input CollectionRunCreateNestedOneWithoutResponsesInput {
  connect: CollectionRunWhereUniqueInput
  connectOrCreate: CollectionRunCreateOrConnectWithoutResponsesInput
  create: CollectionRunCreateWithoutResponsesInput
}

input CollectionRunCreateOrConnectWithoutCollectionInput {
  create: CollectionRunCreateWithoutCollectionInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunCreateOrConnectWithoutResponsesInput {
  create: CollectionRunCreateWithoutResponsesInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunCreateWithoutCollectionInput {
  createdAt: DateTime
  responses: ResponseCreateNestedManyWithoutCollectionRunInput
}

input CollectionRunCreateWithoutResponsesInput {
  collection: CollectionCreateNestedOneWithoutCollectionRunsInput
  createdAt: DateTime
}

type CollectionRunGroupBy {
  _avg: CollectionRunAvgAggregate
  _count: CollectionRunCountAggregate
  _max: CollectionRunMaxAggregate
  _min: CollectionRunMinAggregate
  _sum: CollectionRunSumAggregate
  collectionId: Int
  createdAt: DateTime!
  id: Int!
}

input CollectionRunListRelationFilter {
  every: CollectionRunWhereInput
  none: CollectionRunWhereInput
  some: CollectionRunWhereInput
}

type CollectionRunMaxAggregate {
  collectionId: Int
  createdAt: DateTime
  id: Int
}

input CollectionRunMaxOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
}

type CollectionRunMinAggregate {
  collectionId: Int
  createdAt: DateTime
  id: Int
}

input CollectionRunMinOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
}

input CollectionRunOrderByRelationAggregateInput {
  _count: SortOrder
}

input CollectionRunOrderByWithAggregationInput {
  _avg: CollectionRunAvgOrderByAggregateInput
  _count: CollectionRunCountOrderByAggregateInput
  _max: CollectionRunMaxOrderByAggregateInput
  _min: CollectionRunMinOrderByAggregateInput
  _sum: CollectionRunSumOrderByAggregateInput
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
}

input CollectionRunOrderByWithRelationInput {
  collection: CollectionOrderByWithRelationInput
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  responses: ResponseOrderByRelationAggregateInput
}

input CollectionRunRelationFilter {
  is: CollectionRunWhereInput
  isNot: CollectionRunWhereInput
}

enum CollectionRunScalarFieldEnum {
  collectionId
  createdAt
  id
}

input CollectionRunScalarWhereInput {
  AND: [CollectionRunScalarWhereInput!]
  NOT: [CollectionRunScalarWhereInput!]
  OR: [CollectionRunScalarWhereInput!]
  collectionId: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
}

input CollectionRunScalarWhereWithAggregatesInput {
  AND: [CollectionRunScalarWhereWithAggregatesInput!]
  NOT: [CollectionRunScalarWhereWithAggregatesInput!]
  OR: [CollectionRunScalarWhereWithAggregatesInput!]
  collectionId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
}

type CollectionRunSumAggregate {
  collectionId: Int
  id: Int
}

input CollectionRunSumOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
}

input CollectionRunUpdateInput {
  collection: CollectionUpdateOneWithoutCollectionRunsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutCollectionRunNestedInput
}

input CollectionRunUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
}

input CollectionRunUpdateManyWithWhereWithoutCollectionInput {
  data: CollectionRunUpdateManyMutationInput!
  where: CollectionRunScalarWhereInput!
}

input CollectionRunUpdateManyWithoutCollectionNestedInput {
  connect: [CollectionRunWhereUniqueInput!]
  connectOrCreate: [CollectionRunCreateOrConnectWithoutCollectionInput!]
  create: [CollectionRunCreateWithoutCollectionInput!]
  createMany: CollectionRunCreateManyCollectionInputEnvelope
  delete: [CollectionRunWhereUniqueInput!]
  deleteMany: [CollectionRunScalarWhereInput!]
  disconnect: [CollectionRunWhereUniqueInput!]
  set: [CollectionRunWhereUniqueInput!]
  update: [CollectionRunUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [CollectionRunUpdateManyWithWhereWithoutCollectionInput!]
  upsert: [CollectionRunUpsertWithWhereUniqueWithoutCollectionInput!]
}

input CollectionRunUpdateOneWithoutResponsesNestedInput {
  connect: CollectionRunWhereUniqueInput
  connectOrCreate: CollectionRunCreateOrConnectWithoutResponsesInput
  create: CollectionRunCreateWithoutResponsesInput
  delete: Boolean
  disconnect: Boolean
  update: CollectionRunUpdateWithoutResponsesInput
  upsert: CollectionRunUpsertWithoutResponsesInput
}

input CollectionRunUpdateWithWhereUniqueWithoutCollectionInput {
  data: CollectionRunUpdateWithoutCollectionInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunUpdateWithoutCollectionInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutCollectionRunNestedInput
}

input CollectionRunUpdateWithoutResponsesInput {
  collection: CollectionUpdateOneWithoutCollectionRunsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
}

input CollectionRunUpsertWithWhereUniqueWithoutCollectionInput {
  create: CollectionRunCreateWithoutCollectionInput!
  update: CollectionRunUpdateWithoutCollectionInput!
  where: CollectionRunWhereUniqueInput!
}

input CollectionRunUpsertWithoutResponsesInput {
  create: CollectionRunCreateWithoutResponsesInput!
  update: CollectionRunUpdateWithoutResponsesInput!
}

input CollectionRunWhereInput {
  AND: [CollectionRunWhereInput!]
  NOT: [CollectionRunWhereInput!]
  OR: [CollectionRunWhereInput!]
  collection: CollectionRelationFilter
  collectionId: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  responses: ResponseListRelationFilter
}

input CollectionRunWhereUniqueInput {
  id: Int
}

enum CollectionScalarFieldEnum {
  createdAt
  id
  monitorId
  title
}

input CollectionScalarWhereInput {
  AND: [CollectionScalarWhereInput!]
  NOT: [CollectionScalarWhereInput!]
  OR: [CollectionScalarWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  monitorId: IntNullableFilter
  title: StringFilter
}

input CollectionScalarWhereWithAggregatesInput {
  AND: [CollectionScalarWhereWithAggregatesInput!]
  NOT: [CollectionScalarWhereWithAggregatesInput!]
  OR: [CollectionScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  monitorId: IntNullableWithAggregatesFilter
  title: StringWithAggregatesFilter
}

type CollectionSumAggregate {
  id: Int
  monitorId: Int
}

input CollectionSumOrderByAggregateInput {
  id: SortOrder
  monitorId: SortOrder
}

input CollectionUpdateInput {
  collectionRuns: CollectionRunUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  monitor: MonitorUpdateOneWithoutCollectionsNestedInput
  requests: RequestUpdateManyWithoutCollectionNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateManyWithWhereWithoutMonitorInput {
  data: CollectionUpdateManyMutationInput!
  where: CollectionScalarWhereInput!
}

input CollectionUpdateManyWithoutMonitorNestedInput {
  connect: [CollectionWhereUniqueInput!]
  connectOrCreate: [CollectionCreateOrConnectWithoutMonitorInput!]
  create: [CollectionCreateWithoutMonitorInput!]
  createMany: CollectionCreateManyMonitorInputEnvelope
  delete: [CollectionWhereUniqueInput!]
  deleteMany: [CollectionScalarWhereInput!]
  disconnect: [CollectionWhereUniqueInput!]
  set: [CollectionWhereUniqueInput!]
  update: [CollectionUpdateWithWhereUniqueWithoutMonitorInput!]
  updateMany: [CollectionUpdateManyWithWhereWithoutMonitorInput!]
  upsert: [CollectionUpsertWithWhereUniqueWithoutMonitorInput!]
}

input CollectionUpdateOneWithoutCollectionRunsNestedInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutCollectionRunsInput
  create: CollectionCreateWithoutCollectionRunsInput
  delete: Boolean
  disconnect: Boolean
  update: CollectionUpdateWithoutCollectionRunsInput
  upsert: CollectionUpsertWithoutCollectionRunsInput
}

input CollectionUpdateOneWithoutRequestsNestedInput {
  connect: CollectionWhereUniqueInput
  connectOrCreate: CollectionCreateOrConnectWithoutRequestsInput
  create: CollectionCreateWithoutRequestsInput
  delete: Boolean
  disconnect: Boolean
  update: CollectionUpdateWithoutRequestsInput
  upsert: CollectionUpsertWithoutRequestsInput
}

input CollectionUpdateWithWhereUniqueWithoutMonitorInput {
  data: CollectionUpdateWithoutMonitorInput!
  where: CollectionWhereUniqueInput!
}

input CollectionUpdateWithoutCollectionRunsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  monitor: MonitorUpdateOneWithoutCollectionsNestedInput
  requests: RequestUpdateManyWithoutCollectionNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateWithoutMonitorInput {
  collectionRuns: CollectionRunUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  requests: RequestUpdateManyWithoutCollectionNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpdateWithoutRequestsInput {
  collectionRuns: CollectionRunUpdateManyWithoutCollectionNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  monitor: MonitorUpdateOneWithoutCollectionsNestedInput
  title: StringFieldUpdateOperationsInput
}

input CollectionUpsertWithWhereUniqueWithoutMonitorInput {
  create: CollectionCreateWithoutMonitorInput!
  update: CollectionUpdateWithoutMonitorInput!
  where: CollectionWhereUniqueInput!
}

input CollectionUpsertWithoutCollectionRunsInput {
  create: CollectionCreateWithoutCollectionRunsInput!
  update: CollectionUpdateWithoutCollectionRunsInput!
}

input CollectionUpsertWithoutRequestsInput {
  create: CollectionCreateWithoutRequestsInput!
  update: CollectionUpdateWithoutRequestsInput!
}

input CollectionWhereInput {
  AND: [CollectionWhereInput!]
  NOT: [CollectionWhereInput!]
  OR: [CollectionWhereInput!]
  collectionRuns: CollectionRunListRelationFilter
  createdAt: DateTimeFilter
  id: IntFilter
  monitor: MonitorRelationFilter
  monitorId: IntNullableFilter
  requests: RequestListRelationFilter
  title: StringFilter
}

input CollectionWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input DeleteRequestInput {
  collectionId: Float!
  requestId: Float!
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonNullableFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedJsonNullableFilter
  _min: NestedJsonNullableFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Monitor {
  _count: MonitorCount
  collections(cursor: CollectionWhereUniqueInput, distinct: [CollectionScalarFieldEnum!], orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): [Collection!]!
  contactInfo: JSON
  createdAt: DateTime!
  enabled: Boolean!
  id: Int!
  schedule: String!
  snsTopicArn: String
}

type MonitorAvgAggregate {
  id: Float
}

input MonitorAvgOrderByAggregateInput {
  id: SortOrder
}

type MonitorCount {
  collections: Int!
}

type MonitorCountAggregate {
  _all: Int!
  contactInfo: Int!
  createdAt: Int!
  enabled: Int!
  id: Int!
  schedule: Int!
  snsTopicArn: Int!
}

input MonitorCountOrderByAggregateInput {
  contactInfo: SortOrder
  createdAt: SortOrder
  enabled: SortOrder
  id: SortOrder
  schedule: SortOrder
  snsTopicArn: SortOrder
}

input MonitorCreateInput {
  collections: CollectionCreateNestedManyWithoutMonitorInput
  contactInfo: JSON
  createdAt: DateTime
  enabled: Boolean
  schedule: String!
  snsTopicArn: String
}

input MonitorCreateManyInput {
  contactInfo: JSON
  createdAt: DateTime
  enabled: Boolean
  id: Int
  schedule: String!
  snsTopicArn: String
}

input MonitorCreateNestedOneWithoutCollectionsInput {
  connect: MonitorWhereUniqueInput
  connectOrCreate: MonitorCreateOrConnectWithoutCollectionsInput
  create: MonitorCreateWithoutCollectionsInput
}

input MonitorCreateOrConnectWithoutCollectionsInput {
  create: MonitorCreateWithoutCollectionsInput!
  where: MonitorWhereUniqueInput!
}

input MonitorCreateWithoutCollectionsInput {
  contactInfo: JSON
  createdAt: DateTime
  enabled: Boolean
  schedule: String!
  snsTopicArn: String
}

type MonitorGroupBy {
  _avg: MonitorAvgAggregate
  _count: MonitorCountAggregate
  _max: MonitorMaxAggregate
  _min: MonitorMinAggregate
  _sum: MonitorSumAggregate
  contactInfo: JSON
  createdAt: DateTime!
  enabled: Boolean!
  id: Int!
  schedule: String!
  snsTopicArn: String
}

type MonitorMaxAggregate {
  createdAt: DateTime
  enabled: Boolean
  id: Int
  schedule: String
  snsTopicArn: String
}

input MonitorMaxOrderByAggregateInput {
  createdAt: SortOrder
  enabled: SortOrder
  id: SortOrder
  schedule: SortOrder
  snsTopicArn: SortOrder
}

type MonitorMinAggregate {
  createdAt: DateTime
  enabled: Boolean
  id: Int
  schedule: String
  snsTopicArn: String
}

input MonitorMinOrderByAggregateInput {
  createdAt: SortOrder
  enabled: SortOrder
  id: SortOrder
  schedule: SortOrder
  snsTopicArn: SortOrder
}

input MonitorOrderByWithAggregationInput {
  _avg: MonitorAvgOrderByAggregateInput
  _count: MonitorCountOrderByAggregateInput
  _max: MonitorMaxOrderByAggregateInput
  _min: MonitorMinOrderByAggregateInput
  _sum: MonitorSumOrderByAggregateInput
  contactInfo: SortOrder
  createdAt: SortOrder
  enabled: SortOrder
  id: SortOrder
  schedule: SortOrder
  snsTopicArn: SortOrder
}

input MonitorOrderByWithRelationInput {
  collections: CollectionOrderByRelationAggregateInput
  contactInfo: SortOrder
  createdAt: SortOrder
  enabled: SortOrder
  id: SortOrder
  schedule: SortOrder
  snsTopicArn: SortOrder
}

input MonitorRelationFilter {
  is: MonitorWhereInput
  isNot: MonitorWhereInput
}

enum MonitorScalarFieldEnum {
  contactInfo
  createdAt
  enabled
  id
  schedule
  snsTopicArn
}

input MonitorScalarWhereWithAggregatesInput {
  AND: [MonitorScalarWhereWithAggregatesInput!]
  NOT: [MonitorScalarWhereWithAggregatesInput!]
  OR: [MonitorScalarWhereWithAggregatesInput!]
  contactInfo: JsonNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  enabled: BoolWithAggregatesFilter
  id: IntWithAggregatesFilter
  schedule: StringWithAggregatesFilter
  snsTopicArn: StringNullableWithAggregatesFilter
}

type MonitorSumAggregate {
  id: Int
}

input MonitorSumOrderByAggregateInput {
  id: SortOrder
}

input MonitorUpdateInput {
  collections: CollectionUpdateManyWithoutMonitorNestedInput
  contactInfo: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  enabled: BoolFieldUpdateOperationsInput
  schedule: StringFieldUpdateOperationsInput
  snsTopicArn: NullableStringFieldUpdateOperationsInput
}

input MonitorUpdateManyMutationInput {
  contactInfo: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  enabled: BoolFieldUpdateOperationsInput
  schedule: StringFieldUpdateOperationsInput
  snsTopicArn: NullableStringFieldUpdateOperationsInput
}

input MonitorUpdateOneWithoutCollectionsNestedInput {
  connect: MonitorWhereUniqueInput
  connectOrCreate: MonitorCreateOrConnectWithoutCollectionsInput
  create: MonitorCreateWithoutCollectionsInput
  delete: Boolean
  disconnect: Boolean
  update: MonitorUpdateWithoutCollectionsInput
  upsert: MonitorUpsertWithoutCollectionsInput
}

input MonitorUpdateWithoutCollectionsInput {
  contactInfo: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  enabled: BoolFieldUpdateOperationsInput
  schedule: StringFieldUpdateOperationsInput
  snsTopicArn: NullableStringFieldUpdateOperationsInput
}

input MonitorUpsertWithoutCollectionsInput {
  create: MonitorCreateWithoutCollectionsInput!
  update: MonitorUpdateWithoutCollectionsInput!
}

input MonitorWhereInput {
  AND: [MonitorWhereInput!]
  NOT: [MonitorWhereInput!]
  OR: [MonitorWhereInput!]
  collections: CollectionListRelationFilter
  contactInfo: JsonNullableFilter
  createdAt: DateTimeFilter
  enabled: BoolFilter
  id: IntFilter
  schedule: StringFilter
  snsTopicArn: StringNullableFilter
}

input MonitorWhereUniqueInput {
  id: Int
}

type Mutation {
  createManyAssertion(data: [AssertionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyAssertionResult(data: [AssertionResultCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCollection(data: [CollectionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyCollectionRun(data: [CollectionRunCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMonitor(data: [MonitorCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyRequest(data: [RequestCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyResponse(data: [ResponseCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneAssertion(data: AssertionCreateInput!): Assertion!
  createOneAssertionResult(data: AssertionResultCreateInput!): AssertionResult!
  createOneCollection(data: CollectionCreateInput!): Collection!
  createOneCollectionRun(data: CollectionRunCreateInput!): CollectionRun!
  createOneMonitor(data: MonitorCreateInput!): Monitor!
  createOneRequest(data: RequestCreateInput!): Request!
  createOneResponse(data: ResponseCreateInput!): Response!
  deleteManyAssertion(where: AssertionWhereInput): AffectedRowsOutput!
  deleteManyAssertionResult(where: AssertionResultWhereInput): AffectedRowsOutput!
  deleteManyCollection(where: CollectionWhereInput): AffectedRowsOutput!
  deleteManyCollectionRun(where: CollectionRunWhereInput): AffectedRowsOutput!
  deleteManyMonitor(where: MonitorWhereInput): AffectedRowsOutput!
  deleteManyRequest(where: RequestWhereInput): AffectedRowsOutput!
  deleteManyResponse(where: ResponseWhereInput): AffectedRowsOutput!
  deleteOneAssertion(where: AssertionWhereUniqueInput!): Assertion
  deleteOneAssertionResult(where: AssertionResultWhereUniqueInput!): AssertionResult
  deleteOneCollection(where: CollectionWhereUniqueInput!): Collection
  deleteOneCollectionRun(where: CollectionRunWhereUniqueInput!): CollectionRun
  deleteOneMonitor(where: MonitorWhereUniqueInput!): Monitor
  deleteOneRequest(where: RequestWhereUniqueInput!): Request
  deleteOneResponse(where: ResponseWhereUniqueInput!): Response
  deleteRequest(data: DeleteRequestInput!): [Request!]
  reorderRequests(data: ReorderRequestInput!): [Request!]
  updateManyAssertion(data: AssertionUpdateManyMutationInput!, where: AssertionWhereInput): AffectedRowsOutput!
  updateManyAssertionResult(data: AssertionResultUpdateManyMutationInput!, where: AssertionResultWhereInput): AffectedRowsOutput!
  updateManyCollection(data: CollectionUpdateManyMutationInput!, where: CollectionWhereInput): AffectedRowsOutput!
  updateManyCollectionRun(data: CollectionRunUpdateManyMutationInput!, where: CollectionRunWhereInput): AffectedRowsOutput!
  updateManyMonitor(data: MonitorUpdateManyMutationInput!, where: MonitorWhereInput): AffectedRowsOutput!
  updateManyRequest(data: RequestUpdateManyMutationInput!, where: RequestWhereInput): AffectedRowsOutput!
  updateManyResponse(data: ResponseUpdateManyMutationInput!, where: ResponseWhereInput): AffectedRowsOutput!
  updateOneAssertion(data: AssertionUpdateInput!, where: AssertionWhereUniqueInput!): Assertion
  updateOneAssertionResult(data: AssertionResultUpdateInput!, where: AssertionResultWhereUniqueInput!): AssertionResult
  updateOneCollection(data: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection
  updateOneCollectionRun(data: CollectionRunUpdateInput!, where: CollectionRunWhereUniqueInput!): CollectionRun
  updateOneMonitor(data: MonitorUpdateInput!, where: MonitorWhereUniqueInput!): Monitor
  updateOneRequest(data: RequestUpdateInput!, where: RequestWhereUniqueInput!): Request
  updateOneResponse(data: ResponseUpdateInput!, where: ResponseWhereUniqueInput!): Response
  upsertOneAssertion(create: AssertionCreateInput!, update: AssertionUpdateInput!, where: AssertionWhereUniqueInput!): Assertion!
  upsertOneAssertionResult(create: AssertionResultCreateInput!, update: AssertionResultUpdateInput!, where: AssertionResultWhereUniqueInput!): AssertionResult!
  upsertOneCollection(create: CollectionCreateInput!, update: CollectionUpdateInput!, where: CollectionWhereUniqueInput!): Collection!
  upsertOneCollectionRun(create: CollectionRunCreateInput!, update: CollectionRunUpdateInput!, where: CollectionRunWhereUniqueInput!): CollectionRun!
  upsertOneMonitor(create: MonitorCreateInput!, update: MonitorUpdateInput!, where: MonitorWhereUniqueInput!): Monitor!
  upsertOneRequest(create: RequestCreateInput!, update: RequestUpdateInput!, where: RequestWhereUniqueInput!): Request!
  upsertOneResponse(create: ResponseCreateInput!, update: ResponseUpdateInput!, where: ResponseWhereUniqueInput!): Response!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatNullableFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatNullableFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntNullableWithAggregatesFilter {
  _avg: NestedFloatNullableFilter
  _count: NestedIntNullableFilter
  _max: NestedIntNullableFilter
  _min: NestedIntNullableFilter
  _sum: NestedIntNullableFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableWithAggregatesFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedJsonNullableFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateAssertion(cursor: AssertionWhereUniqueInput, orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): AggregateAssertion!
  aggregateAssertionResult(cursor: AssertionResultWhereUniqueInput, orderBy: [AssertionResultOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionResultWhereInput): AggregateAssertionResult!
  aggregateCollection(cursor: CollectionWhereUniqueInput, orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): AggregateCollection!
  aggregateCollectionRun(cursor: CollectionRunWhereUniqueInput, orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): AggregateCollectionRun!
  aggregateMonitor(cursor: MonitorWhereUniqueInput, orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): AggregateMonitor!
  aggregateRequest(cursor: RequestWhereUniqueInput, orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): AggregateRequest!
  aggregateResponse(cursor: ResponseWhereUniqueInput, orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): AggregateResponse!
  assertion(where: AssertionWhereUniqueInput!): Assertion
  assertionResult(where: AssertionResultWhereUniqueInput!): AssertionResult
  assertionResults(cursor: AssertionResultWhereUniqueInput, distinct: [AssertionResultScalarFieldEnum!], orderBy: [AssertionResultOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionResultWhereInput): [AssertionResult!]!
  assertions(cursor: AssertionWhereUniqueInput, distinct: [AssertionScalarFieldEnum!], orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): [Assertion!]!
  collection(where: CollectionWhereUniqueInput!): Collection
  collectionRun(where: CollectionRunWhereUniqueInput!): CollectionRun
  collectionRuns(cursor: CollectionRunWhereUniqueInput, distinct: [CollectionRunScalarFieldEnum!], orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): [CollectionRun!]!
  collections(cursor: CollectionWhereUniqueInput, distinct: [CollectionScalarFieldEnum!], orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): [Collection!]!
  findFirstAssertion(cursor: AssertionWhereUniqueInput, distinct: [AssertionScalarFieldEnum!], orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): Assertion
  findFirstAssertionResult(cursor: AssertionResultWhereUniqueInput, distinct: [AssertionResultScalarFieldEnum!], orderBy: [AssertionResultOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionResultWhereInput): AssertionResult
  findFirstCollection(cursor: CollectionWhereUniqueInput, distinct: [CollectionScalarFieldEnum!], orderBy: [CollectionOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionWhereInput): Collection
  findFirstCollectionRun(cursor: CollectionRunWhereUniqueInput, distinct: [CollectionRunScalarFieldEnum!], orderBy: [CollectionRunOrderByWithRelationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): CollectionRun
  findFirstMonitor(cursor: MonitorWhereUniqueInput, distinct: [MonitorScalarFieldEnum!], orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): Monitor
  findFirstRequest(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): Request
  findFirstResponse(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): Response
  groupByAssertion(by: [AssertionScalarFieldEnum!]!, having: AssertionScalarWhereWithAggregatesInput, orderBy: [AssertionOrderByWithAggregationInput!], skip: Int, take: Int, where: AssertionWhereInput): [AssertionGroupBy!]!
  groupByAssertionResult(by: [AssertionResultScalarFieldEnum!]!, having: AssertionResultScalarWhereWithAggregatesInput, orderBy: [AssertionResultOrderByWithAggregationInput!], skip: Int, take: Int, where: AssertionResultWhereInput): [AssertionResultGroupBy!]!
  groupByCollection(by: [CollectionScalarFieldEnum!]!, having: CollectionScalarWhereWithAggregatesInput, orderBy: [CollectionOrderByWithAggregationInput!], skip: Int, take: Int, where: CollectionWhereInput): [CollectionGroupBy!]!
  groupByCollectionRun(by: [CollectionRunScalarFieldEnum!]!, having: CollectionRunScalarWhereWithAggregatesInput, orderBy: [CollectionRunOrderByWithAggregationInput!], skip: Int, take: Int, where: CollectionRunWhereInput): [CollectionRunGroupBy!]!
  groupByMonitor(by: [MonitorScalarFieldEnum!]!, having: MonitorScalarWhereWithAggregatesInput, orderBy: [MonitorOrderByWithAggregationInput!], skip: Int, take: Int, where: MonitorWhereInput): [MonitorGroupBy!]!
  groupByRequest(by: [RequestScalarFieldEnum!]!, having: RequestScalarWhereWithAggregatesInput, orderBy: [RequestOrderByWithAggregationInput!], skip: Int, take: Int, where: RequestWhereInput): [RequestGroupBy!]!
  groupByResponse(by: [ResponseScalarFieldEnum!]!, having: ResponseScalarWhereWithAggregatesInput, orderBy: [ResponseOrderByWithAggregationInput!], skip: Int, take: Int, where: ResponseWhereInput): [ResponseGroupBy!]!
  monitor(where: MonitorWhereUniqueInput!): Monitor
  monitors(cursor: MonitorWhereUniqueInput, distinct: [MonitorScalarFieldEnum!], orderBy: [MonitorOrderByWithRelationInput!], skip: Int, take: Int, where: MonitorWhereInput): [Monitor!]!
  request(where: RequestWhereUniqueInput!): Request
  requests(cursor: RequestWhereUniqueInput, distinct: [RequestScalarFieldEnum!], orderBy: [RequestOrderByWithRelationInput!], skip: Int, take: Int, where: RequestWhereInput): [Request!]!
  response(where: ResponseWhereUniqueInput!): Response
  responses(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): [Response!]!
}

enum QueryMode {
  default
  insensitive
}

input ReorderRequestInput {
  collectionId: Float!
  fromStep: Float!
  toStep: Float!
}

type Request {
  _count: RequestCount
  assertions(cursor: AssertionWhereUniqueInput, distinct: [AssertionScalarFieldEnum!], orderBy: [AssertionOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionWhereInput): [Assertion!]!
  body: JSON
  collection: Collection
  collectionId: Int
  createdAt: DateTime!
  headers: JSON
  id: Int!
  method: String!
  responses(cursor: ResponseWhereUniqueInput, distinct: [ResponseScalarFieldEnum!], orderBy: [ResponseOrderByWithRelationInput!], skip: Int, take: Int, where: ResponseWhereInput): [Response!]!
  stepNumber: Int!
  title: String!
  url: String!
}

type RequestAvgAggregate {
  collectionId: Float
  id: Float
  stepNumber: Float
}

input RequestAvgOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
  stepNumber: SortOrder
}

type RequestCount {
  assertions: Int!
  responses: Int!
}

type RequestCountAggregate {
  _all: Int!
  body: Int!
  collectionId: Int!
  createdAt: Int!
  headers: Int!
  id: Int!
  method: Int!
  stepNumber: Int!
  title: Int!
  url: Int!
}

input RequestCountOrderByAggregateInput {
  body: SortOrder
  collectionId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  method: SortOrder
  stepNumber: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestCreateInput {
  assertions: AssertionCreateNestedManyWithoutRequestInput
  body: JSON
  collection: CollectionCreateNestedOneWithoutRequestsInput
  createdAt: DateTime
  headers: JSON
  method: String!
  responses: ResponseCreateNestedManyWithoutRequestInput
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestCreateManyCollectionInput {
  body: JSON
  createdAt: DateTime
  headers: JSON
  id: Int
  method: String!
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestCreateManyCollectionInputEnvelope {
  data: [RequestCreateManyCollectionInput!]!
  skipDuplicates: Boolean
}

input RequestCreateManyInput {
  body: JSON
  collectionId: Int
  createdAt: DateTime
  headers: JSON
  id: Int
  method: String!
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestCreateNestedManyWithoutCollectionInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutCollectionInput!]
  create: [RequestCreateWithoutCollectionInput!]
  createMany: RequestCreateManyCollectionInputEnvelope
}

input RequestCreateNestedOneWithoutAssertionsInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutAssertionsInput
  create: RequestCreateWithoutAssertionsInput
}

input RequestCreateNestedOneWithoutResponsesInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutResponsesInput
  create: RequestCreateWithoutResponsesInput
}

input RequestCreateOrConnectWithoutAssertionsInput {
  create: RequestCreateWithoutAssertionsInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateOrConnectWithoutCollectionInput {
  create: RequestCreateWithoutCollectionInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateOrConnectWithoutResponsesInput {
  create: RequestCreateWithoutResponsesInput!
  where: RequestWhereUniqueInput!
}

input RequestCreateWithoutAssertionsInput {
  body: JSON
  collection: CollectionCreateNestedOneWithoutRequestsInput
  createdAt: DateTime
  headers: JSON
  method: String!
  responses: ResponseCreateNestedManyWithoutRequestInput
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestCreateWithoutCollectionInput {
  assertions: AssertionCreateNestedManyWithoutRequestInput
  body: JSON
  createdAt: DateTime
  headers: JSON
  method: String!
  responses: ResponseCreateNestedManyWithoutRequestInput
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestCreateWithoutResponsesInput {
  assertions: AssertionCreateNestedManyWithoutRequestInput
  body: JSON
  collection: CollectionCreateNestedOneWithoutRequestsInput
  createdAt: DateTime
  headers: JSON
  method: String!
  stepNumber: Int!
  title: String!
  url: String!
}

type RequestGroupBy {
  _avg: RequestAvgAggregate
  _count: RequestCountAggregate
  _max: RequestMaxAggregate
  _min: RequestMinAggregate
  _sum: RequestSumAggregate
  body: JSON
  collectionId: Int
  createdAt: DateTime!
  headers: JSON
  id: Int!
  method: String!
  stepNumber: Int!
  title: String!
  url: String!
}

input RequestListRelationFilter {
  every: RequestWhereInput
  none: RequestWhereInput
  some: RequestWhereInput
}

type RequestMaxAggregate {
  collectionId: Int
  createdAt: DateTime
  id: Int
  method: String
  stepNumber: Int
  title: String
  url: String
}

input RequestMaxOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  method: SortOrder
  stepNumber: SortOrder
  title: SortOrder
  url: SortOrder
}

type RequestMinAggregate {
  collectionId: Int
  createdAt: DateTime
  id: Int
  method: String
  stepNumber: Int
  title: String
  url: String
}

input RequestMinOrderByAggregateInput {
  collectionId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  method: SortOrder
  stepNumber: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestOrderByRelationAggregateInput {
  _count: SortOrder
}

input RequestOrderByWithAggregationInput {
  _avg: RequestAvgOrderByAggregateInput
  _count: RequestCountOrderByAggregateInput
  _max: RequestMaxOrderByAggregateInput
  _min: RequestMinOrderByAggregateInput
  _sum: RequestSumOrderByAggregateInput
  body: SortOrder
  collectionId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  method: SortOrder
  stepNumber: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestOrderByWithRelationInput {
  assertions: AssertionOrderByRelationAggregateInput
  body: SortOrder
  collection: CollectionOrderByWithRelationInput
  collectionId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  method: SortOrder
  responses: ResponseOrderByRelationAggregateInput
  stepNumber: SortOrder
  title: SortOrder
  url: SortOrder
}

input RequestRelationFilter {
  is: RequestWhereInput
  isNot: RequestWhereInput
}

enum RequestScalarFieldEnum {
  body
  collectionId
  createdAt
  headers
  id
  method
  stepNumber
  title
  url
}

input RequestScalarWhereInput {
  AND: [RequestScalarWhereInput!]
  NOT: [RequestScalarWhereInput!]
  OR: [RequestScalarWhereInput!]
  body: JsonNullableFilter
  collectionId: IntNullableFilter
  createdAt: DateTimeFilter
  headers: JsonNullableFilter
  id: IntFilter
  method: StringFilter
  stepNumber: IntFilter
  title: StringFilter
  url: StringFilter
}

input RequestScalarWhereWithAggregatesInput {
  AND: [RequestScalarWhereWithAggregatesInput!]
  NOT: [RequestScalarWhereWithAggregatesInput!]
  OR: [RequestScalarWhereWithAggregatesInput!]
  body: JsonNullableWithAggregatesFilter
  collectionId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  headers: JsonNullableWithAggregatesFilter
  id: IntWithAggregatesFilter
  method: StringWithAggregatesFilter
  stepNumber: IntWithAggregatesFilter
  title: StringWithAggregatesFilter
  url: StringWithAggregatesFilter
}

type RequestSumAggregate {
  collectionId: Int
  id: Int
  stepNumber: Int
}

input RequestSumOrderByAggregateInput {
  collectionId: SortOrder
  id: SortOrder
  stepNumber: SortOrder
}

input RequestUpdateInput {
  assertions: AssertionUpdateManyWithoutRequestNestedInput
  body: JSON
  collection: CollectionUpdateOneWithoutRequestsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutRequestNestedInput
  stepNumber: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateManyMutationInput {
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  stepNumber: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateManyWithWhereWithoutCollectionInput {
  data: RequestUpdateManyMutationInput!
  where: RequestScalarWhereInput!
}

input RequestUpdateManyWithoutCollectionNestedInput {
  connect: [RequestWhereUniqueInput!]
  connectOrCreate: [RequestCreateOrConnectWithoutCollectionInput!]
  create: [RequestCreateWithoutCollectionInput!]
  createMany: RequestCreateManyCollectionInputEnvelope
  delete: [RequestWhereUniqueInput!]
  deleteMany: [RequestScalarWhereInput!]
  disconnect: [RequestWhereUniqueInput!]
  set: [RequestWhereUniqueInput!]
  update: [RequestUpdateWithWhereUniqueWithoutCollectionInput!]
  updateMany: [RequestUpdateManyWithWhereWithoutCollectionInput!]
  upsert: [RequestUpsertWithWhereUniqueWithoutCollectionInput!]
}

input RequestUpdateOneWithoutAssertionsNestedInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutAssertionsInput
  create: RequestCreateWithoutAssertionsInput
  delete: Boolean
  disconnect: Boolean
  update: RequestUpdateWithoutAssertionsInput
  upsert: RequestUpsertWithoutAssertionsInput
}

input RequestUpdateOneWithoutResponsesNestedInput {
  connect: RequestWhereUniqueInput
  connectOrCreate: RequestCreateOrConnectWithoutResponsesInput
  create: RequestCreateWithoutResponsesInput
  delete: Boolean
  disconnect: Boolean
  update: RequestUpdateWithoutResponsesInput
  upsert: RequestUpsertWithoutResponsesInput
}

input RequestUpdateWithWhereUniqueWithoutCollectionInput {
  data: RequestUpdateWithoutCollectionInput!
  where: RequestWhereUniqueInput!
}

input RequestUpdateWithoutAssertionsInput {
  body: JSON
  collection: CollectionUpdateOneWithoutRequestsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutRequestNestedInput
  stepNumber: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateWithoutCollectionInput {
  assertions: AssertionUpdateManyWithoutRequestNestedInput
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  responses: ResponseUpdateManyWithoutRequestNestedInput
  stepNumber: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpdateWithoutResponsesInput {
  assertions: AssertionUpdateManyWithoutRequestNestedInput
  body: JSON
  collection: CollectionUpdateOneWithoutRequestsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  method: StringFieldUpdateOperationsInput
  stepNumber: IntFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  url: StringFieldUpdateOperationsInput
}

input RequestUpsertWithWhereUniqueWithoutCollectionInput {
  create: RequestCreateWithoutCollectionInput!
  update: RequestUpdateWithoutCollectionInput!
  where: RequestWhereUniqueInput!
}

input RequestUpsertWithoutAssertionsInput {
  create: RequestCreateWithoutAssertionsInput!
  update: RequestUpdateWithoutAssertionsInput!
}

input RequestUpsertWithoutResponsesInput {
  create: RequestCreateWithoutResponsesInput!
  update: RequestUpdateWithoutResponsesInput!
}

input RequestWhereInput {
  AND: [RequestWhereInput!]
  NOT: [RequestWhereInput!]
  OR: [RequestWhereInput!]
  assertions: AssertionListRelationFilter
  body: JsonNullableFilter
  collection: CollectionRelationFilter
  collectionId: IntNullableFilter
  createdAt: DateTimeFilter
  headers: JsonNullableFilter
  id: IntFilter
  method: StringFilter
  responses: ResponseListRelationFilter
  stepNumber: IntFilter
  title: StringFilter
  url: StringFilter
}

input RequestWhereUniqueInput {
  id: Int
}

type Response {
  _count: ResponseCount
  assertionResults(cursor: AssertionResultWhereUniqueInput, distinct: [AssertionResultScalarFieldEnum!], orderBy: [AssertionResultOrderByWithRelationInput!], skip: Int, take: Int, where: AssertionResultWhereInput): [AssertionResult!]!
  body: JSON
  collectionRun: CollectionRun
  collectionRunId: Int
  createdAt: DateTime!
  headers: JSON!
  id: Int!
  latency: Int!
  request: Request
  requestId: Int
  status: Int!
}

type ResponseAvgAggregate {
  collectionRunId: Float
  id: Float
  latency: Float
  requestId: Float
  status: Float
}

input ResponseAvgOrderByAggregateInput {
  collectionRunId: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

type ResponseCount {
  assertionResults: Int!
}

type ResponseCountAggregate {
  _all: Int!
  body: Int!
  collectionRunId: Int!
  createdAt: Int!
  headers: Int!
  id: Int!
  latency: Int!
  requestId: Int!
  status: Int!
}

input ResponseCountOrderByAggregateInput {
  body: SortOrder
  collectionRunId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseCreateInput {
  assertionResults: AssertionResultCreateNestedManyWithoutResponseInput
  body: JSON
  collectionRun: CollectionRunCreateNestedOneWithoutResponsesInput
  createdAt: DateTime
  headers: JSON!
  latency: Int!
  request: RequestCreateNestedOneWithoutResponsesInput
  status: Int!
}

input ResponseCreateManyCollectionRunInput {
  body: JSON
  createdAt: DateTime
  headers: JSON!
  id: Int
  latency: Int!
  requestId: Int
  status: Int!
}

input ResponseCreateManyCollectionRunInputEnvelope {
  data: [ResponseCreateManyCollectionRunInput!]!
  skipDuplicates: Boolean
}

input ResponseCreateManyInput {
  body: JSON
  collectionRunId: Int
  createdAt: DateTime
  headers: JSON!
  id: Int
  latency: Int!
  requestId: Int
  status: Int!
}

input ResponseCreateManyRequestInput {
  body: JSON
  collectionRunId: Int
  createdAt: DateTime
  headers: JSON!
  id: Int
  latency: Int!
  status: Int!
}

input ResponseCreateManyRequestInputEnvelope {
  data: [ResponseCreateManyRequestInput!]!
  skipDuplicates: Boolean
}

input ResponseCreateNestedManyWithoutCollectionRunInput {
  connect: [ResponseWhereUniqueInput!]
  connectOrCreate: [ResponseCreateOrConnectWithoutCollectionRunInput!]
  create: [ResponseCreateWithoutCollectionRunInput!]
  createMany: ResponseCreateManyCollectionRunInputEnvelope
}

input ResponseCreateNestedManyWithoutRequestInput {
  connect: [ResponseWhereUniqueInput!]
  connectOrCreate: [ResponseCreateOrConnectWithoutRequestInput!]
  create: [ResponseCreateWithoutRequestInput!]
  createMany: ResponseCreateManyRequestInputEnvelope
}

input ResponseCreateNestedOneWithoutAssertionResultsInput {
  connect: ResponseWhereUniqueInput
  connectOrCreate: ResponseCreateOrConnectWithoutAssertionResultsInput
  create: ResponseCreateWithoutAssertionResultsInput
}

input ResponseCreateOrConnectWithoutAssertionResultsInput {
  create: ResponseCreateWithoutAssertionResultsInput!
  where: ResponseWhereUniqueInput!
}

input ResponseCreateOrConnectWithoutCollectionRunInput {
  create: ResponseCreateWithoutCollectionRunInput!
  where: ResponseWhereUniqueInput!
}

input ResponseCreateOrConnectWithoutRequestInput {
  create: ResponseCreateWithoutRequestInput!
  where: ResponseWhereUniqueInput!
}

input ResponseCreateWithoutAssertionResultsInput {
  body: JSON
  collectionRun: CollectionRunCreateNestedOneWithoutResponsesInput
  createdAt: DateTime
  headers: JSON!
  latency: Int!
  request: RequestCreateNestedOneWithoutResponsesInput
  status: Int!
}

input ResponseCreateWithoutCollectionRunInput {
  assertionResults: AssertionResultCreateNestedManyWithoutResponseInput
  body: JSON
  createdAt: DateTime
  headers: JSON!
  latency: Int!
  request: RequestCreateNestedOneWithoutResponsesInput
  status: Int!
}

input ResponseCreateWithoutRequestInput {
  assertionResults: AssertionResultCreateNestedManyWithoutResponseInput
  body: JSON
  collectionRun: CollectionRunCreateNestedOneWithoutResponsesInput
  createdAt: DateTime
  headers: JSON!
  latency: Int!
  status: Int!
}

type ResponseGroupBy {
  _avg: ResponseAvgAggregate
  _count: ResponseCountAggregate
  _max: ResponseMaxAggregate
  _min: ResponseMinAggregate
  _sum: ResponseSumAggregate
  body: JSON
  collectionRunId: Int
  createdAt: DateTime!
  headers: JSON!
  id: Int!
  latency: Int!
  requestId: Int
  status: Int!
}

input ResponseListRelationFilter {
  every: ResponseWhereInput
  none: ResponseWhereInput
  some: ResponseWhereInput
}

type ResponseMaxAggregate {
  collectionRunId: Int
  createdAt: DateTime
  id: Int
  latency: Int
  requestId: Int
  status: Int
}

input ResponseMaxOrderByAggregateInput {
  collectionRunId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

type ResponseMinAggregate {
  collectionRunId: Int
  createdAt: DateTime
  id: Int
  latency: Int
  requestId: Int
  status: Int
}

input ResponseMinOrderByAggregateInput {
  collectionRunId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseOrderByRelationAggregateInput {
  _count: SortOrder
}

input ResponseOrderByWithAggregationInput {
  _avg: ResponseAvgOrderByAggregateInput
  _count: ResponseCountOrderByAggregateInput
  _max: ResponseMaxOrderByAggregateInput
  _min: ResponseMinOrderByAggregateInput
  _sum: ResponseSumOrderByAggregateInput
  body: SortOrder
  collectionRunId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseOrderByWithRelationInput {
  assertionResults: AssertionResultOrderByRelationAggregateInput
  body: SortOrder
  collectionRun: CollectionRunOrderByWithRelationInput
  collectionRunId: SortOrder
  createdAt: SortOrder
  headers: SortOrder
  id: SortOrder
  latency: SortOrder
  request: RequestOrderByWithRelationInput
  requestId: SortOrder
  status: SortOrder
}

input ResponseRelationFilter {
  is: ResponseWhereInput
  isNot: ResponseWhereInput
}

enum ResponseScalarFieldEnum {
  body
  collectionRunId
  createdAt
  headers
  id
  latency
  requestId
  status
}

input ResponseScalarWhereInput {
  AND: [ResponseScalarWhereInput!]
  NOT: [ResponseScalarWhereInput!]
  OR: [ResponseScalarWhereInput!]
  body: JsonNullableFilter
  collectionRunId: IntNullableFilter
  createdAt: DateTimeFilter
  headers: JsonFilter
  id: IntFilter
  latency: IntFilter
  requestId: IntNullableFilter
  status: IntFilter
}

input ResponseScalarWhereWithAggregatesInput {
  AND: [ResponseScalarWhereWithAggregatesInput!]
  NOT: [ResponseScalarWhereWithAggregatesInput!]
  OR: [ResponseScalarWhereWithAggregatesInput!]
  body: JsonNullableWithAggregatesFilter
  collectionRunId: IntNullableWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  headers: JsonWithAggregatesFilter
  id: IntWithAggregatesFilter
  latency: IntWithAggregatesFilter
  requestId: IntNullableWithAggregatesFilter
  status: IntWithAggregatesFilter
}

type ResponseSumAggregate {
  collectionRunId: Int
  id: Int
  latency: Int
  requestId: Int
  status: Int
}

input ResponseSumOrderByAggregateInput {
  collectionRunId: SortOrder
  id: SortOrder
  latency: SortOrder
  requestId: SortOrder
  status: SortOrder
}

input ResponseUpdateInput {
  assertionResults: AssertionResultUpdateManyWithoutResponseNestedInput
  body: JSON
  collectionRun: CollectionRunUpdateOneWithoutResponsesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  request: RequestUpdateOneWithoutResponsesNestedInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpdateManyMutationInput {
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpdateManyWithWhereWithoutCollectionRunInput {
  data: ResponseUpdateManyMutationInput!
  where: ResponseScalarWhereInput!
}

input ResponseUpdateManyWithWhereWithoutRequestInput {
  data: ResponseUpdateManyMutationInput!
  where: ResponseScalarWhereInput!
}

input ResponseUpdateManyWithoutCollectionRunNestedInput {
  connect: [ResponseWhereUniqueInput!]
  connectOrCreate: [ResponseCreateOrConnectWithoutCollectionRunInput!]
  create: [ResponseCreateWithoutCollectionRunInput!]
  createMany: ResponseCreateManyCollectionRunInputEnvelope
  delete: [ResponseWhereUniqueInput!]
  deleteMany: [ResponseScalarWhereInput!]
  disconnect: [ResponseWhereUniqueInput!]
  set: [ResponseWhereUniqueInput!]
  update: [ResponseUpdateWithWhereUniqueWithoutCollectionRunInput!]
  updateMany: [ResponseUpdateManyWithWhereWithoutCollectionRunInput!]
  upsert: [ResponseUpsertWithWhereUniqueWithoutCollectionRunInput!]
}

input ResponseUpdateManyWithoutRequestNestedInput {
  connect: [ResponseWhereUniqueInput!]
  connectOrCreate: [ResponseCreateOrConnectWithoutRequestInput!]
  create: [ResponseCreateWithoutRequestInput!]
  createMany: ResponseCreateManyRequestInputEnvelope
  delete: [ResponseWhereUniqueInput!]
  deleteMany: [ResponseScalarWhereInput!]
  disconnect: [ResponseWhereUniqueInput!]
  set: [ResponseWhereUniqueInput!]
  update: [ResponseUpdateWithWhereUniqueWithoutRequestInput!]
  updateMany: [ResponseUpdateManyWithWhereWithoutRequestInput!]
  upsert: [ResponseUpsertWithWhereUniqueWithoutRequestInput!]
}

input ResponseUpdateOneWithoutAssertionResultsNestedInput {
  connect: ResponseWhereUniqueInput
  connectOrCreate: ResponseCreateOrConnectWithoutAssertionResultsInput
  create: ResponseCreateWithoutAssertionResultsInput
  delete: Boolean
  disconnect: Boolean
  update: ResponseUpdateWithoutAssertionResultsInput
  upsert: ResponseUpsertWithoutAssertionResultsInput
}

input ResponseUpdateWithWhereUniqueWithoutCollectionRunInput {
  data: ResponseUpdateWithoutCollectionRunInput!
  where: ResponseWhereUniqueInput!
}

input ResponseUpdateWithWhereUniqueWithoutRequestInput {
  data: ResponseUpdateWithoutRequestInput!
  where: ResponseWhereUniqueInput!
}

input ResponseUpdateWithoutAssertionResultsInput {
  body: JSON
  collectionRun: CollectionRunUpdateOneWithoutResponsesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  request: RequestUpdateOneWithoutResponsesNestedInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpdateWithoutCollectionRunInput {
  assertionResults: AssertionResultUpdateManyWithoutResponseNestedInput
  body: JSON
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  request: RequestUpdateOneWithoutResponsesNestedInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpdateWithoutRequestInput {
  assertionResults: AssertionResultUpdateManyWithoutResponseNestedInput
  body: JSON
  collectionRun: CollectionRunUpdateOneWithoutResponsesNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  headers: JSON
  latency: IntFieldUpdateOperationsInput
  status: IntFieldUpdateOperationsInput
}

input ResponseUpsertWithWhereUniqueWithoutCollectionRunInput {
  create: ResponseCreateWithoutCollectionRunInput!
  update: ResponseUpdateWithoutCollectionRunInput!
  where: ResponseWhereUniqueInput!
}

input ResponseUpsertWithWhereUniqueWithoutRequestInput {
  create: ResponseCreateWithoutRequestInput!
  update: ResponseUpdateWithoutRequestInput!
  where: ResponseWhereUniqueInput!
}

input ResponseUpsertWithoutAssertionResultsInput {
  create: ResponseCreateWithoutAssertionResultsInput!
  update: ResponseUpdateWithoutAssertionResultsInput!
}

input ResponseWhereInput {
  AND: [ResponseWhereInput!]
  NOT: [ResponseWhereInput!]
  OR: [ResponseWhereInput!]
  assertionResults: AssertionResultListRelationFilter
  body: JsonNullableFilter
  collectionRun: CollectionRunRelationFilter
  collectionRunId: IntNullableFilter
  createdAt: DateTimeFilter
  headers: JsonFilter
  id: IntFilter
  latency: IntFilter
  request: RequestRelationFilter
  requestId: IntNullableFilter
  status: IntFilter
}

input ResponseWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}
